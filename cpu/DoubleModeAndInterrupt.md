#  이중 모드와 인터럽트
2022.02.05
##  1. 프로세스의 두 가지의 실행 상태
> Q: 만약 어떤 프로그램이 컴퓨터의 전원을 끄는 명령어를 실행 시킨다면 어떻게 될까?
> A: 실행 중인 다른 프로그램이나 다른 사용자의 프로그램이 영향을 받을 수 있다. 공장에서 배전반의 전원을 끄면 공장이 멈추는 비상상황이 발생하듯이 컴퓨터도 그런 치명적인 명령들은 특수한 권한을 가진 모드가 수행하도록 모드를 나눠 놓았다.

###  1.1. user mode
* 프로세스가 cpu 운영권을 갖고 프로세스 자신의 주소 공간에 있는 코드를 실행할 때 적용하는 모드이다. 
* 사용자 함수나 라이브러리를 사용하는 등의 일반적인 명령을 수행할 때 이 모드의 상태이다.

###  1.2. kernel mode
> 운영체제는 여러 프로그램이 동시에 수행되는 시스템을 위한 운영체제이다. 프로그램이 수행되려면 그 프로그램이 메모리에 올라가 있어야 한다. 운영체제는 컴퓨터 부팅시부터 각종 자원을 관리하기 위해 항상 메모리에 올라가 있다. 하지만 운영체제의 모든 코드를 다 메모리에 상주시키면 메모리의 낭비가 발생하게 된다. 따라서 운영체제 중 항상 메모리에 올라가 있는 부분은 전체 운영체제 중 핵심적인 부분에 한정되며, 이 부분을 커널(kernel)이라고 부른다. 
    - 운영체제와 정보기술의 원리, p69 -

* 운영체제가 cpu 운영권을 갖고 커널 명령을 수행할 수 있는 모드이다. 
* 시스템 콜이나 인터럽트, Stop(), exit() 등의 특권 명령을 수행할 때 이 모드의 상태이다.

### 1.3. 두 모드를 구별하는 방법
* 레지스터에 모드를 나타내는 플래그가 존재하는데 이를 모드 비트라 하며 0과 1값을 통해 커널모드인지 사용자모드인지를 판단한다.
*   * 0 : 커널 모드
*   * 1 : 사용자 모드

### 1.4. 하나의 프로세스를 예시로 살펴보자
> 예를 들어 프로세스 A가 CPU에서 실행되고 있다고 하자.
다음의 두가지로 나눠 볼 수 있다.

    1. 자신의 주소 공간에 정의된 코드를 실행하는 것
    2. 커널의 시스템 콜 함수를 실행하는 것

* 1번을 사용자 모드에서의 실행 상태(user mode running)이라 하고 2번을 커널모드에서의 실행상태(kernel mode running)라 한다.
* 시스템 콜을 통해 커널의 코드를 실행하더라도 이는 프로그램 A의 요청을 대행한 것이므로 커널이 실행상태에 있다고 하지 않고, 프로세스 A가 실행 상태에 있다고 말한다.

![사용자모드와 커널모드를 통해 프로그램이 수행되는 과정](https://user-images.githubusercontent.com/50472122/152646243-d3577821-564c-455d-8047-fcbe8b5c1dcf.png)


##  2. 인터럽트
### 2.1. 컴퓨터 시스템의 구조
> 우선 컴퓨터가 하는 일에 대해서 알아 보자. 

    * 컴퓨터는 내부 장치인 
        * CPU, 메모리 
    * 외부 장치인 
        * 디스크, 키보드, 마우스, 모니터, 네트워크 장치등으로 구성 된다.
        
![컴퓨터 내부장치와 외부장치 구조](https://user-images.githubusercontent.com/50472122/152646256-b69a2330-c5bc-478b-a03e-5875b6665bd7.png)


    * 컨트롤러: 일종의 작은 CPU, 각 하드웨어 장치마다 존재하며 이들을 제어
    * 로컬버퍼: 일종의 작은 메모리, 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
    
`컴퓨터는 외부 장치에서 내부 장치로 데이터를 읽어와 각종 연산을 수행한 후, 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.` 이 때 컴퓨터 내부로 데이터가 들어오는 것을 입력(input)이라 하고, 컴퓨터 외부 장치로 데이터가 나가는 것을 출력(output)이라고 한다. 

### 2.2. CPU 연산과 I/O 연산
> 예를 들어 B라는 프로그램이 현재 CPU를 할당받아 프로그램 코드를 수행하고, A라는 프로그램은 하드디스크에서 어떠한 정보를 읽어오는 작업을 수행하는 상황을 생각해 볼 수 있다.
--> 두가지 일이 다른 곳에서 발생하므로 동시에 수행되는 것이 가능하다.

* I/O 연산의 예시: 디스크나 키보드 등에서 데이터를 읽어오는 경우 순서(현재 프로그램B가 진행중)
```
1. 프로그램 B가 수행 중에 디스크에서 데이터를 읽어오라는 명령을 내림
2. 디스크 컨트롤러가 물리적인 디스크에서 내용을 읽어 이를 로컬버퍼에 저장
3. 디스크 컨트롤러가 인터럽트를 발생시켜 CPU에 보고
4. CPU는 옆에 인터럽트 라인(interrupt line)에 불이 들어온 것을 보고 하던일을 멈추고 인터럽트와 관련된 일을 먼저 처리
```

### 2.3. 인터럽트의 일반적 기능
> 운영체제 커널에는 인터럽트가 들어왔을 때 해야 할 일이 미리 다 프로그래밍되어 그 코드가 보관돼 있다. 운영체제 커널 내에 있는 인터럽트 처리루틴은 다양한 인터럽트에 대해 각각 처리해야할 업무들을 정의하고 있다. 운영체제는 인터럽트가 발생했을 때 할일을 쉽게 찾아가기 위해 인터럽트 벡터(interrupt vectoer)를 가지고 있다. 인터럽트 벡터란 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 가리키고 있는 자료구조를 말한다. 실제 코드는 인터럽트 처리루틴이라 불리는 곳에 정의된다.
--> 인터럽트 벡터 --> 인터럽트 처리루틴

* 인터럽트 구분
*   * 하드웨어 인터럽트(통상적)
*   * 소프트웨어 인터럽트(trap)
*   *   * 예외 상황(exception)과 시스템 콜(system call)


 `예외 상황`: 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도하거나 자신의 메모리 영역 바깥에 접근하려는 시도 등 권한 없는 작업을 시도할 때 발생시키는 인터럽트
`시스템 콜`: 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법, 사용자 프로그램에 정의되지 않고 운영체제 커널에 있는 코드를 사용자 프로그램이 실행하고자 할 때에는 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행하게 됨.
예) 키보드 입력, 화면 입출력 등

### 2.4. 인터럽트 핸들링
> 인터럽트가 발생한 경우에 처리해야 할 일의 절차
```
\프로그램 A 실행중\
1. 인터럽트가 발생하면 A의 현재 상태를 먼저 PCB에 저장
    * 레지스터에 있는 데이터를 프로그램마다 존재하는 PCB에 저장
        * PCB(process control block): 메모리 주소, 레지스터값, 하드웨어 상태 등이 저장됨 
2. CPU의 제어권이 인터럽트 처리루틴으로 넘어감
3. 인터럽트 처리가 끝나면 저장된 상태를 PCB로부터 CPU상에 복원
4. 인터럽트 당하기 직전의 위치부터 실행이 이어지게 됨
```

* 오늘날의 운영체제는 인터럽트가 발생할 때에만 실행되므로 CPU가 항상 사용자 프로그램에 의해 사용된다.
* * 즉, 인터럽트가 발생할 때에만 운영체제 코드 부분으로 CPU가 이양되어 인터럽트 처리를 수행하게 된다.
