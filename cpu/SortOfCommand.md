# 명령의 종류
|연산에 관한 명령|연산 이외의 명령  |
|-------|-------|
|1. 산술 연산 명령  | 4. 데이터 전송 명령 |
|2. 논리 연산 명령 |5. 입출력 명령 |
|3. 시프트 연산 명령 |6. 분기 명령 |
| |7. 조건 판단 (비교 명령 등) |

# 연산에 관한 명령

## 산술 연산, 논리 연산

* 산술 연산
	* PLUS(덧셈)
	* MINUS(뺄셈)
* 논리 연산
	* AND - 논리곱
	*  OR - 논리합  
	* NOT - 부정
	
## 시프트 연산

해당 조작은 연산 결과를 일시적으로 기억하는 어큐뮬레이터에서 처리된다.

* 논리 오른쪽 시프트 (2비트)

|2진수|10진수|
|-----|-----|
|0110 0100| 100|
|0001 1001|25|

### 시프트 정리
* N 비트를 왼쪽 시프트 하면
	* 2^N 배라는 곱셈이 된다.
* N 비트를 오른쪽 시프트 하면,
	* 1/2^N 배라는 나눗셈이 된다.

## 음수는 어떻게 나타낼까? 

* 부호 비트
	* 최상위 비트에서 양 = 0 이나 음 = 1 을 나타내는 비트
	* 최상위는 부호비트, 나머지 비트로는 숫자를 나타냄
		* 011 => 3
		* 101 => -3

위의 개념을 이해하기 위해선 보수의 개념을 이해해야한다. 

원래수와 더해서 0이 나오는 수가 보수이다.
컴퓨터는 덧셈 뿐이 못하는 바보이니까...

### 보수 구하는 법
```swift
011		// 1. 각 자리를 모두 반전 시킨다.
100		// 2. 1을 더한다
101		// 짜잔 -3 이다. 
```

이렇게 되면 재미있는 점이 있다. 
보통 3비트이면, '0 ~ 7' 까지의 8개의 수를 나타낸다.
다만, 부호 비트가 있는 3비트는 '-4 ~ 3' 의 8개 수를 나타낸다.

인간이 이해하기는 까다롭지만 컴퓨터는 최상위 비트에 부호 비트를 담고 있다는 것을 표시하는 플래그가 있다. 이 플래그를 프로그램 안에서 감시함으로써 이상한 부호 변화가 있는지 알 수 있는 것이다. 

## 논리 시프트와 산술 시프트
이제 시프트의 본편이다. 
* 시프트
	* 논리 시프트
		* 부호 없음
	* 산술 시프트 
		* 부호 있음

논리 시프트는 사실 단순하다. 시프트 해도 고려할 게 그닥 없다. 왜 와이(Y)? 최상위 비트가 0이라 우리 생각한 그대로 하면 된다. 

다만 문제 되는 부분은, 산술 시프트이다. 음수와 양수 모드 시프트가 가능한데, 어떠한 식으로 구현하는지 살펴보자. 
![산술 오른쪽 시프트](https://user-images.githubusercontent.com/50472122/164952291-e326d2ee-4804-4b45-b452-1096faffab81.jpeg)

'논리 시프트'는 그냥 0 으로 채우면 됐는데, '산술 시프트'는 부호 비트를 의식해야한다. 

오른쪽 산술 시프트는 저렇다 치고,  왼쪽 산술 시프트는 어떻게 해야할까? 만약 최상위 비호 비트 바로 다음 비트에 1이 자리 잡고 있다면? 맞다. **마치 1이 최상위 비트가 되어서 음수 처럼 보인다.** 

원래 왼쪽 시프트로 정수를 2^n 배 해야 하는데, **부호가 반전**하고 있다. 이를 **오버 플로우(OverFlow)** 라고 한다. 물이 넘친다는 뜻을 담고 있는 오버 플로우는  **CS 적으로는 연산의 결과가 취급할 수 있는 자릿수의 상한을 넘어섰다는 이야기이다.**

물론 컴공 박사님들은 이 경우에 처리해야할 로직을 마련해 두셨다. 오버 플로우가 나타나면, **스테이터스 레지스터 안의 오버플로 플래그(오버플로 비트) 가 설정된다.**

### 여기서 잠깐!? 언더플로란?

부동 소수점 연산에서 0.00000000....1이라는 한없이 0에 가까운 값이 되었을 때, 너무 작은 숫자라서 정확히 표현할 수 없다. 이것을 언더 플로(하위 자리 넘침)이라 한다. 
우리는 정수값의 연산에 초점을 맞추고 있고, 또한, 정수값과 부동 소수점 연산의 경우 연산의 취급과 방식이 서로 다르다.

### 서큘러 시프트(로테이트 시프트)

원형으로 회전하는 시프트이다. 아주 직관적인데, 비트 열 양 끝이 연결되어 고리가 되어 있고, 그 고리가 회전하는 이미지를 떠올리면 좋다.  
![left circular shift](https://media.geeksforgeeks.org/wp-content/uploads/20200922114921/233434.PNG)
문제는 이러한 순환 시프트를 어디에 사용하느냐 이다. 이게 궁금해서 찾아봤는데 주로 섞고, 랜덤한 글자를 만들어 내는데 사용한다고 한다. 뭔가 원형으로 연결된 그림도 연상되고, 모듈러 함수에 적용되는 개념인것도 싶다. 

예시) 
Josephus survivor problem 에 나온다고 한다. 

# 연산 이외의 명령

## 데이터 전송 명령

데이터를 주고 받기에 관한 명령
CPU(레지스터)와 메모리 사이에 행해지는 읽기와 쓰기 명령이 있다.
또 레지스터 끼리도 움직이는 경우도 있다. 

## 입출력 명령

I/O 포트를 사용해 외부장치와 CPU 사이에 데이터의 입출력을 담당하는 명령이다.

## 분기 명령(분-기잇!)

![분기-잇](https://user-images.githubusercontent.com/50472122/164953529-069fe8e7-f061-4ca2-babe-2e087a8d3624.jpeg)
다음에 실행해야 할 명령의 어드레스 번지로 훌쩍 점프하는 이미지이다. 위 그림에서 지금 실행하고 있는 명령의 어드레스가 7번이지만, 다음은 15번으로 점프할 수도 있고, 거꾸로 3번으로 점프할 수도 있다. 
즉, **프로그램의 흐름을 바꾼다, 혹은 제어한다!**
그리고 또한, 무조건 점프하는 점프와 일정 조건을 충족해야 하는 점프가 있다.
* 분기(점프)
	* 무조건 점프
	* 조건 점프
	* 소년(?) 점프
	
또 점프를 거리감에 따라서 구분하는 시각도 존재한다

* 거리감에 따른 점프 구분
 (모든 CPU에서 같지 않고 제조사별로다름)
	* 브랜치 
		* 지금 실행하고 있는 곳에서 그리 멀지 않은 앞이나 뒤의 어드레스로 분기한다
	* 점프 명령
		* 브랜치 명령보다 더 먼 어드레스로 분기한다
	* 스킵 명령
		* 바로 다음 명령을 실행하거나 그 명령만 실행하지 않고 건너뛴다.

이 밖에도, 흐름 제어는 STOP, SLEEP 등이 있다. 

## 조건 판단과 스테이터스 플래그

예전에 한 번 든 예시인데, 스테이터스 플래그를 이해하려면, 은행 잔고를 나타내는 ATM 을 생각하면 좋다.

|연산 결과가 플러스|연산 결과가 마이너스 |
|----|----|
|"현금을 받아주세요" |"잔고가 부족합니다" |

여기서 연산 결과를 저장하는 플래그를 스테이터스 플래그라고 한다. 
상태를 기억해두는 것이 바로 스테이터스 플래그. 0이냐, 1이냐에 따라 어떤 일정한 상태를 기억하고 있다. 

| 플래그 | 0(리셋) | 1(세트) |
|----|----|----|
|스테이터스 | 계산 결과 + | 계산 결과 - |
|사인(부호) | 연산 결과 양수 | 연산 결과 음수 |
|캐리 | 자리 올림 x | 자리 올림 o |

이런 플래그(각각 1비트)를 8비트나 16비트로 정리한 것을 스테이터스 레지스터라고 한다!

![스테이터스 레지스터](https://user-images.githubusercontent.com/50472122/164954043-99f2625d-dc85-4f22-961a-da968b5d82a4.jpeg)

분기 판단과 조건 판단을 조합해 
"연산 결과가 음(-)일 때, 특정 명령 번지로 점프한다" 라는 조합이 가능하다! 컴퓨터를 프로그램답게 만들어주는 친구들을 만나 보았다. 

