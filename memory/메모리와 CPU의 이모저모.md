# 메모리와 CPU의 이모저모

## 메모리에는 어드레스가 할당되어 있다.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRiYtHUC1eJO9m1RYBaTY80xINhsq5v6NNLMw&usqp=CAU" alt="CPU,Memory" style="zoom:200%;" />

메모리에는 **데이터와 프로그램**이 들어있다. CPU 와 데이터 등을 주고 받습니다. 메모리 안에는 프로그램과 데이터가 빈틈없이 저장되어 있다.

| 번지 | 종류 |
| ---- | ---- |
| 0번  | 명령 |
| 1번  | 명령 |
| 2번  | 명령 |
| 3번  | 명령 |

...		



어드레스(번지)가 있어서 말끔히 정리 정돈 되어있다. CPU가 직접 관리하고 있는 공간을 어드레스 공간이라고 합니다!

한번 더! **어드레스 공간(메모리 공간)은 CPU의 지배 관리 밑**

이렇게 되면 원하는 데이터를 번호로 지정할 수 있고, CPU가 "83번 주세요 ~" 라고 메모리에게 요청할 수 있다. 



## 버스는 데이터의 통로

* 어드레스 버스 : "x번, y번 주세요" 라는 CPU 의 명령을 전달하는 버스를 어드레스 버스라고 합니다. 
* 데이터 버스 : 실제로 데이터를 주고 받는 버스를 데이터 버스라고 합니다.
* 외부 버스 : CPU 와 외부 장치를 연결하는 버스이다. 대표적으로 CPU와 메모리를 이어주는 버스를 외부 버스라 한다. 
* 내부 버스 : CPU 내부를 연결하는 버스입니다. **멀티플렉서(MUX)** 라는 것이 있다. CPU 내 데이터 버스의 배선을 간소화 할 수 있어서 아주 편리하다.

![각종 버스](https://miro.medium.com/max/1037/1*PkyAoPTJU33SkhtoODqdBA.png)



## 버스 폭과 비트 수 

2^4 = 16 가지 경우의 수

버스는 데이터의 통로라고 했는데 구체적으로는 신호선을 다발로 묶은 것이다. 

* 신호선 : 0 이나 1(L or H) 라는 전기 신호가 지나다니는 선
  * 4가닥의 신호선이 있으면 4자리의 2진수를 나타낼 수 있다. 

결국 **"신호선의 가닥수 = 비트 수"** 가 되는 것입니다. 이렇다는 것은 신호선의 수(비트 수)가 많은 쪽이 이득입니다.

큰 수(자릿수)를 표현할 수 있으면 한 번에 다룰 수 있는 데이터가 큰 것입니다.

"신호선의 가닥수 = 비트 수" 를 **버스폭** 이라고 합니다. 버스 폭이 넓을 수록 (비트 수가 많을 수록) CPU의 처리 능력이 향상됩니다.

<img src="https://hellocbt.com/files/attach/images/2020/12/23/da4176f10cf99e84d0bea40296a049de.gif" alt="ALU와 버스폭" style="zoom:200%;" />

> ALU 의 처리폭에 따라 데이터 버스 폭을 맞추는 것이 합리적이여서, 데이터 버스 폭도 결과적으로 64 비트가 되는 경우가 많습니다.

위의 그림은 ALU 의 처리 폭입니다. 정리하자면, 

* 외부 데이터 버스 폭 : CPU 와 메모리를 연결하는 버스의 폭으로, 한 번에 데이터를 몇 비트(몇 자리) 주고 받을 수 있는지 를 결정
* 내부 데이터 버스 폭: CPU 내부 ALU 의 입력에 연결하는 내부 데이터 버스 폭으로 한 번에 연산을 몇 비트(몇 자리) 할 수 있는지 알 수 있다.



## 어드레스 버스 폭

> 어드레스를 몇 비트(몇 자리) 취급할 수 있는지를 나타낸다. 이에 따라 어드레스 공간의 크기도 이걸로 정해진다. 

예를 들어 

* 어드레스 비트 폭 : 4비트 -> 어드레스의 수는 16

* 어드레스 비트 폭 : 32 비트 -> 어드레스의 수는 2^32 = 4,294,967,296(약 4.3G)의 어드레스가 존재 할 수 있다.

또한 어드레스 버스폭은 어느 정도의 메모리 용량을 다룰 수 있는가 하는 문제와도 연결된다. 

**메모리의 용량과 버스 폭(비트 수)**에 대하여 생각해보자. 

다음 그림과 같이 하나의 어드레스에 1Byte 의 데이터가 할당되어 있다고 가정해보자. 1Byte = 8 bit 이고, 8bit 가 데이터 버스의 폭이 된다. 

이 경우에 어드레스 공간(어드레스 버스 폭)이 12비트이면 어드레스의 수는 4096이 된다, 하나의 어드레스에 1Byte 의 데이터를 취급할 수 있으므로, 메모리 용량의 상한은 4096Byte = 4KByte 가 된다.

**어드레스 -> 8Bit = 1 Byte**

| 0번  | 0 1 0 0 1 0 1 0 |
| ---- | --------------- |
| 1번  | 1 1 1 0 0 1 0 1 |



## R / W 제어, I / O 제어

READ, WRITE : 읽기 / 쓰기로 하드웨어 측에서 메모리에 대한 전기적 동작(읽기/쓰기)이다. 읽은 데이터를 어디로 가져갈 것인지, 어디에 있는 데이터를 쓸 것인지에 대해서는 관여하지 않는다. 

LOAD, STORE : 소프트 웨어 측에서 본 표현인데, 메모리에서 읽은 데이터를 레지스터로 이동 시키는 것을 로드, 레지스터에서 데이터를 이동시켜 메모리에 쓰는 것을 스토어라 한다. 

* READ : 저장되어 있는 데이터를 추출
* WRITE : 데이터를 기록해서 저장

* Load : 메모리 -> 레지스터
* Store : 레지스터 -> 메모리 , 데이터의 흐름을 의식



CPU 가 내리는 명령에는 데이터를 꺼내라, 데이터를 저장하라와 같이 제어명령도 같이 전달된다. 

예를 들어 83번 데이터가 필요하다 같은 경우엔

* 어드레스 번호 83번
* 제어 신호 : READ
* 실제 데이터는 데이터 버스로 오고감

### I / O

* Input : 외부에서 컴퓨터로 데이터를 보내는 것
  *  키보드, 마우스

* Output : 컴퓨터에서 외부로 데이터를 보내는 것
  *  디스플레이, 프린터 
* I/O 포트 : 외부와 데이터 주고 받기를 하는 현관 역할 
  * CPU 와 키보드는 I/O 포트로 직접 연결되어 있다.



**CPU 와 메모리 사이에도 어드레스 포트, 데이터 포트 라는 것이 있는데, 어드레스 버스나 데이터 버스가 연결되어 있다!**

![CPU 개념도](https://user-images.githubusercontent.com/50472122/161407774-aa4df9e4-a5b3-4663-a6fa-9ce91634c660.jpeg)

